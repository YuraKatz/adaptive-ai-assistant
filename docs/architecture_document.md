# Architecture Documentation

## üèóÔ∏è System Overview

Adaptive AI Assistant –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É —Å event-driven –ø–æ–¥—Ö–æ–¥–æ–º –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∏–∞–ª–æ–≥–æ–≤ –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–Ω–∞–Ω–∏–π.

### Core Principles:
- **AI-First Decision Making** ‚Äî –≤—Å–µ —Ä–µ—à–µ–Ω–∏—è –æ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏–Ω–∏–º–∞–µ—Ç AI
- **Incremental Learning** ‚Äî —Å–∏—Å—Ç–µ–º–∞ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ –æ–±—É—á–∞–µ—Ç—Å—è –∏–∑ –¥–∏–∞–ª–æ–≥–æ–≤
- **Domain Agnostic** ‚Äî –æ–¥–Ω–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –¥–ª—è –ª—é–±—ã—Ö –±–∏–∑–Ω–µ—Å-–¥–æ–º–µ–Ω–æ–≤
- **Human-in-the-Loop** ‚Äî –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç –≤—Å–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–Ω–∞–Ω–∏–π

---

## üîÑ Data Flow Architecture

```mermaid
sequenceDiagram
    participant U as User
    participant TB as Telegram Bot
    participant AO as Azure Orchestrator
    participant AI as Claude AI
    participant KB as Knowledge Base
    participant KA as Knowledge API

    U->>TB: "–°—Ç–∞—Ç—É—Å –ø—Ä–æ–µ–∫—Ç–∞ X?"
    TB->>AO: webhook message
    AO->>AI: "Analyze query + determine context needs"
    AI->>AO: "Search for: project_status, timeline, issues"
    AO->>KB: semantic search request
    KB->>AO: relevant context data
    AO->>AI: "Query + Context"
    AI->>AO: "Intelligent response + knowledge updates"
    AO->>TB: response message
    TB->>U: "Project X: 78% complete, on track..."
    
    Note over AI,KA: Knowledge Update Flow
    AI->>AO: "Detected new info: project milestone"
    AO->>TB: "Save to knowledge base? [Yes/No]"
    U->>TB: Click "Yes"
    TB->>AO: confirmation
    AO->>KA: execute update command
    KA->>KB: update YAML + Git commit
    KA->>AO: success confirmation
    AO->>TB: "‚úÖ Saved to projects.yaml"
    TB->>U: success notification
```

---

## üß© Component Architecture

### 1. **Telegram Bot Service**

**Technology:** Node.js + Telegraf framework
**Responsibilities:**
- Handle incoming messages and commands
- Display interactive buttons and forms
- Send notifications and responses
- File uploads and media handling

**Key Files:**
```
src/telegram-bot/
‚îú‚îÄ‚îÄ bot.js              # Main bot logic
‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îú‚îÄ‚îÄ message.js      # Text message handler
‚îÇ   ‚îú‚îÄ‚îÄ callback.js     # Button callback handler
‚îÇ   ‚îî‚îÄ‚îÄ command.js      # Bot commands (/start, /help)
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ auth.js         # User authentication
‚îÇ   ‚îî‚îÄ‚îÄ logging.js      # Request logging
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ keyboards.js    # Interactive keyboards
    ‚îî‚îÄ‚îÄ formatting.js   # Message formatting
```

### 2. **Azure Orchestrator Service**

**Technology:** Azure Functions + TypeScript
**Responsibilities:**
- Receive webhooks from Telegram
- Coordinate between AI and Knowledge systems
- Manage conversation state and context
- Handle error recovery and retries

**Key Functions:**
```
src/azure-functions/
‚îú‚îÄ‚îÄ TelegramWebhook/    # HTTP trigger for Telegram
‚îú‚îÄ‚îÄ ProcessMessage/     # Queue trigger for message processing
‚îú‚îÄ‚îÄ UpdateKnowledge/    # Queue trigger for knowledge updates
‚îú‚îÄ‚îÄ ContextManager/     # Durable function for conversation state
‚îî‚îÄ‚îÄ shared/
    ‚îú‚îÄ‚îÄ types.ts        # TypeScript interfaces
    ‚îú‚îÄ‚îÄ config.ts       # Configuration management
    ‚îî‚îÄ‚îÄ utils.ts        # Shared utilities
```

**Event Flow:**
```typescript
interface MessageEvent {
  userId: string;
  message: string;
  timestamp: Date;
  conversationId: string;
}

interface KnowledgeUpdateEvent {
  action: 'create_file' | 'update_file' | 'add_section';
  targetFile: string;
  content: any;
  reason: string;
  confidence: number;
}
```

### 3. **Claude AI Integration**

**Technology:** Anthropic Claude API
**Responsibilities:**
- Natural language understanding
- Context requirement analysis
- Knowledge synthesis from multiple sources
- New information detection and structuring

**AI Prompt Structure:**
```yaml
system_prompt: |
  You are an adaptive AI assistant that helps users manage their knowledge base.
  
  Core responsibilities:
  1. Analyze user queries to determine what context is needed
  2. Provide intelligent responses based on available knowledge
  3. Detect when conversations contain new information worth saving
  4. Suggest appropriate knowledge base updates with structured data
  
  Knowledge Base Structure:
  - projects.yaml: Project status, timelines, team info
  - meetings.yaml: Meeting notes, decisions, action items
  - clients.yaml: Client contacts, history, preferences
  - tasks.yaml: Task assignments, deadlines, priorities
  
  When suggesting updates, always provide:
  - Target file and location
  - Structured data in YAML format
  - Reasoning for the suggestion
  - Confidence level (0.0-1.0)

user_context: |
  Current knowledge base contents: {knowledge_summary}
  Recent conversation history: {conversation_history}
  User preferences: {user_preferences}
```

### 4. **Knowledge API Service**

**Technology:** C# ASP.NET Core
**Responsibilities:**
- CRUD operations on YAML files
- Git version control management
- Data validation and schema enforcement
- Backup and recovery operations

**API Endpoints:**
```csharp
public class KnowledgeController : ControllerBase
{
    [HttpPost("files/{filename}")]
    public async Task<IActionResult> CreateFile(string filename, [FromBody] CreateFileRequest request)
    
    [HttpPut("files/{filename}")]
    public async Task<IActionResult> UpdateFile(string filename, [FromBody] UpdateFileRequest request)
    
    [HttpPost("files/{filename}/sections")]
    public async Task<IActionResult> AddSection(string filename, [FromBody] AddSectionRequest request)
    
    [HttpGet("search")]
    public async Task<IActionResult> SearchKnowledge([FromQuery] SearchRequest request)
    
    [HttpPost("backup")]
    public async Task<IActionResult> CreateBackup()
    
    [HttpPost("rollback/{commitId}")]
    public async Task<IActionResult> RollbackToCommit(string commitId)
}
```

### 5. **Knowledge Base Storage**

**Technology:** YAML files + Git + (Future: Weaviate Vector DB)

**File Structure:**
```
knowledge-base/
‚îú‚îÄ‚îÄ .git/                    # Git version control
‚îú‚îÄ‚îÄ projects.yaml            # Project management data
‚îú‚îÄ‚îÄ meetings.yaml            # Meeting notes and decisions
‚îú‚îÄ‚îÄ clients.yaml             # Client information
‚îú‚îÄ‚îÄ tasks.yaml               # Task assignments and deadlines
‚îú‚îÄ‚îÄ knowledge.yaml           # General knowledge and solutions
‚îú‚îÄ‚îÄ contacts.yaml            # Contact information
‚îî‚îÄ‚îÄ templates/
    ‚îú‚îÄ‚îÄ project-template.yaml
    ‚îú‚îÄ‚îÄ meeting-template.yaml
    ‚îî‚îÄ‚îÄ client-template.yaml
```

**YAML Schema Example:**
```yaml
# projects.yaml
projects:
  adaptive_ai_assistant:
    status: "in_development"
    priority: "high"
    start_date: "2025-08-01"
    deadline: "2025-10-01"
    team:
      - name: "Yuri Katz"
        role: "Lead Developer"
    milestones:
      - name: "MVP Release"
        date: "2025-09-15"
        status: "in_progress"
    issues:
      - description: "Need to finalize Weaviate integration"
        severity: "medium"
        assigned_to: "Yuri Katz"
        created: "2025-08-09"
```

---

## üîç Search and Context Resolution

### Current Implementation (MVP):
- **Simple text search** —á–µ—Ä–µ–∑ YAML —Ñ–∞–π–ª—ã
- **Pattern matching** –¥–ª—è –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
- **File-based routing** (–ø—Ä–æ–µ–∫—Ç—ã ‚Üí projects.yaml)

### Future Implementation (Vector DB):
```mermaid
graph TD
    A[User Query] --> B[AI Query Analysis]
    B --> C[Vector Search in Weaviate]
    B --> D[YAML File Search]
    C --> E[Semantic Results]
    D --> F[Structured Results]
    E --> G[Context Synthesis]
    F --> G
    G --> H[AI Response Generation]
```

**Vector Database Integration:**
```yaml
weaviate_config:
  cluster_url: "https://cluster.weaviate.network"
  classes:
    - name: "KnowledgeChunk"
      properties:
        - name: "content"
          dataType: ["text"]
        - name: "source_file" 
          dataType: ["string"]
        - name: "domain"
          dataType: ["string"]
        - name: "timestamp"
          dataType: ["date"]
  vectorizer: "text2vec-openai"
```

---

## üîê Security Architecture

### Authentication & Authorization:
- **Telegram User ID** –∫–∞–∫ primary identifier
- **Whitelist approach** - —Ç–æ–ª—å–∫–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
- **Role-based access** –¥–ª—è –±—É–¥—É—â–∏—Ö multi-user —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤

### Data Protection:
- **Encryption at rest** –¥–ª—è —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
- **TLS encryption** –¥–ª—è –≤—Å–µ—Ö API calls
- **Git history preservation** —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –æ—á–∏—Å—Ç–∫–∏

### API Security:
```csharp
[Authorize]
[ApiKey] 
public class KnowledgeController : ControllerBase
{
    // All endpoints require authentication
}

public class ApiKeyAttribute : Attribute, IAuthorizationFilter
{
    public void OnAuthorization(AuthorizationFilterContext context)
    {
        var apiKey = context.HttpContext.Request.Headers["X-API-Key"];
        if (!ValidateApiKey(apiKey))
        {
            context.Result = new UnauthorizedResult();
        }
    }
}
```

---

## üìä Monitoring & Observability

### Application Insights Integration:
```csharp
public class TelemetryService
{
    public void TrackUserQuery(string userId, string query, TimeSpan responseTime);
    public void TrackKnowledgeUpdate(string fileName, string updateType);
    public void TrackAIConfidence(double confidence, bool userAccepted);
    public void TrackError(Exception ex, string context);
}
```

### Key Metrics:
- **Response Time:** P50, P95, P99 –¥–ª—è –≤—Å–µ—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
- **AI Accuracy:** –ø—Ä–æ—Ü–µ–Ω—Ç —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤
- **Knowledge Growth:** –Ω–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏ –≤ –¥–µ–Ω—å/–Ω–µ–¥–µ–ª—é
- **User Engagement:** –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏, frequency of use

### Health Checks:
- Claude API availability
- Git repository accessibility  
- YAML file integrity
- Telegram Bot connectivity

---

## üöÄ Deployment Architecture

### Development Environment:
```yaml
# docker-compose.yml
version: '3.8'
services:
  telegram-bot:
    build: ./src/telegram-bot
    environment:
      - TELEGRAM_TOKEN=${TELEGRAM_TOKEN}
      - AZURE_FUNCTION_URL=${AZURE_FUNCTION_URL}
  
  knowledge-api:
    build: ./src/knowledge-api
    volumes:
      - ./knowledge-base:/app/knowledge-base
    environment:
      - GIT_REPO_PATH=/app/knowledge-base
```

### Production Environment:
- **Azure Functions** –¥–ª—è serverless compute
- **Azure Container Instances** –¥–ª—è Knowledge API
- **GitHub** –¥–ª—è Git-based knowledge storage
- **Application Insights** –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞

---

## üõ£Ô∏è Evolution Strategy

### Phase 1 ‚Üí Phase 2 Migration:
```mermaid
graph LR
    A[YAML Files] --> B[YAML + Vector DB]
    B --> C[Pure Vector DB]
    
    A1[Simple Search] --> B1[Hybrid Search]
    B1 --> C1[Semantic Search]
    
    A2[Manual Updates] --> B2[AI Suggestions] 
    B2 --> C2[Autonomous Learning]
```

### Backward Compatibility:
- YAML —Ñ–∞–π–ª—ã –æ—Å—Ç–∞—é—Ç—Å—è primary source of truth
- Vector DB –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ search index
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å rollback –∫ pure YAML system

---

*–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: 09.08.2025*